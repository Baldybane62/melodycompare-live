

import type { AnalysisResultPayload, BrainstormMode, ChatMessage, AnalysisData, ChatContext, CatalogItem } from '../types';

const API_BASE_URL = '/api'; // Use relative path for same-origin requests

/**
 * A helper function to handle API responses and errors.
 * @param response The fetch Response object.
 * @returns The JSON response.
 * @throws An error if the response is not ok.
 */
async function handleResponse(response: Response) {
    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'An unknown API error occurred.' }));
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
    }
    // Handle streaming responses
    if (response.headers.get('Content-Type')?.includes('text/plain')) {
        return response.body;
    }
    // Handle empty responses (e.g., 204 No Content)
    if (response.status === 204) {
        return { success: true };
    }
    return response.json();
}

export async function analyzeFile(file: File): Promise<AnalysisResultPayload> {
    const formData = new FormData();
    formData.append('audioFile', file);
    const response = await fetch(`${API_BASE_URL}/analyze`, { method: 'POST', body: formData });
    return handleResponse(response);
}

export async function compareFiles(aiSong: File, copyrightedSong: File): Promise<AnalysisResultPayload> {
    const formData = new FormData();
    formData.append('aiSong', aiSong);
    formData.append('copyrightedSong', copyrightedSong);
    const response = await fetch(`${API_BASE_URL}/compare`, { method: 'POST', body: formData });
    return handleResponse(response);
}

export async function uploadAnalysisAudio(file: File, analysisId: string): Promise<void> {
    const formData = new FormData();
    formData.append('audioFile', file);
    const response = await fetch(`${API_BASE_URL}/analysis-audio/${analysisId}`, {
        method: 'POST',
        body: formData,
    });
    await handleResponse(response);
}

export async function getChatAssistantStream(history: ChatMessage[], message: string, context: ChatContext): Promise<ReadableStream<Uint8Array>> {
    const response = await fetch(`${API_BASE_URL}/assistant-chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ history, message, context }),
    });
    const body = await handleResponse(response);
    if (!body) {
        throw new Error("Failed to get chat stream.");
    }
    return body;
}

export async function generateBrainstormingIdeas(analysisData: AnalysisData, mode: BrainstormMode, theme?: string): Promise<string[]> {
    const response = await fetch(`${API_BASE_URL}/brainstorm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ analysisData, mode, theme }),
    });
    return handleResponse(response);
}

export async function enhanceMusicPrompt(basePrompt: string): Promise<string> {
    const response = await fetch(`${API_BASE_URL}/enhance-prompt`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ basePrompt }),
    });
    const data = await handleResponse(response);
    return data.enhancedPrompt;
}

export async function generateReport(analysisData: AnalysisData): Promise<string> {
    const response = await fetch(`${API_BASE_URL}/generate-report`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ analysisData }),
    });
    const data = await handleResponse(response);
    return data.reportText;
}

export async function publishAnalysis(analysisData: AnalysisData, reportText: string): Promise<{ id: string }> {
    const response = await fetch(`${API_BASE_URL}/share`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ analysisData, reportText }),
    });
    return handleResponse(response);
}

export async function getSharedAnalysis(id: string): Promise<AnalysisResultPayload> {
    const response = await fetch(`${API_BASE_URL}/analysis/${id}`);
    return handleResponse(response);
}

export async function sendFeedback(type: string, message: string, email?: string): Promise<{ success: boolean }> {
    const response = await fetch(`${API_BASE_URL}/feedback`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type, message, email }),
    });
    return handleResponse(response);
}

export async function submitToCatalog(formData: FormData): Promise<CatalogItem> {
    const response = await fetch(`${API_BASE_URL}/catalog/submit`, {
        method: 'POST',
        body: formData,
    });
    return handleResponse(response);
}

export async function getCatalogEntries(): Promise<CatalogItem[]> {
    const response = await fetch(`${API_BASE_URL}/catalog/entries`);
    return handleResponse(response);
}

/**
 * Sends a follow-up message to the chat endpoint and returns a readable stream of the response.
 * @param history The entire chat history.
 * @param message The new message from the user.
 * @returns A Promise that resolves to a ReadableStream of the AI's response text.
 */
export async function getReportChatStream(
    history: ChatMessage[],
    message: string
): Promise<ReadableStream<Uint8Array>> {
     try {
        const response = await fetch(`${API_BASE_URL}/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ history, message }),
        });

        const body = await handleApiResponse(response, 'getReportChatStream');
        if (!body) {
            throw new Error("The response body from the stream is null.");
        }
        return body;
    } catch (error) {
        console.error(`Error in getReportChatStream:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to get chat stream: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during getReportChatStream.`);
    }
}

/**
 * Sends a message to the global AI assistant and returns a stream of the response.
 * @param history The chat history.
 * @param message The new user message.
 * @param context The current application context.
 * @returns A promise that resolves to a readable stream of the AI's response.
 */
export async function getChatAssistantStream(
    history: ChatMessage[],
    message: string,
    context: ChatContext
): Promise<ReadableStream<Uint8Array>> {
     try {
        const response = await fetch(`${API_BASE_URL}/assistant-chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ history, message, context }),
        });

        const body = await handleApiResponse(response, 'getChatAssistantStream');
        if (!body) {
            throw new Error("The response body from the stream is null.");
        }
        return body;
    } catch (error) {
        console.error(`Error in getChatAssistantStream:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to get chat assistant stream: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during getChatAssistantStream.`);
    }
}

export async function generateBrainstormingIdeas(
    analysisData: AnalysisData,
    mode: BrainstormMode,
    theme?: string
): Promise<string[]> {
    try {
        const response = await fetch(`${API_BASE_URL}/brainstorm`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ analysisData, mode, theme }),
        });
        return handleApiResponse(response, 'generateBrainstormingIdeas');
    } catch (error) {
         console.error(`Error in generateBrainstormingIdeas:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to generate brainstorming ideas: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during generateBrainstormingIdeas.`);
    }
}

export async function enhanceMusicPrompt(basePrompt: string): Promise<string> {
    try {
        if (!basePrompt) {
            return '';
        }
        const response = await fetch(`${API_BASE_URL}/enhance-prompt`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ basePrompt }),
        });

        const result = await handleApiResponse(response, 'enhanceMusicPrompt');
        return result.enhancedPrompt;
    } catch (error) {
        console.error(`Error in enhanceMusicPrompt:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to enhance music prompt: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during enhanceMusicPrompt.`);
    }
}

export async function generateReport(analysisData: AnalysisData): Promise<string> {
    try {
        const response = await fetch(`${API_BASE_URL}/generate-report`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ analysisData }),
        });
        const result = await handleApiResponse(response, 'generateReport');
        return result.reportText;
    } catch (error) {
        console.error(`Error in generateReport:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to generate report: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during report generation.`);
    }
}


/**
 * Publishes an analysis to the backend to get a shareable link.
 * @param analysisData The analysis data object.
 * @param reportText The generated report text.
 * @returns A promise that resolves to the unique ID of the shared analysis.
 */
export async function publishAnalysis(analysisData: AnalysisData, reportText: string): Promise<{ id: string }> {
    try {
        const response = await fetch(`${API_BASE_URL}/share`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ analysisData, reportText }),
        });
        return handleApiResponse(response, 'publishAnalysis');
    } catch (error) {
        console.error(`Error in publishAnalysis:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to publish analysis: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during analysis publishing.`);
    }
}

/**
 * Retrieves a shared analysis from the backend using its ID.
 * @param id The unique ID of the shared analysis.
 * @returns A promise that resolves to the analysis data and report text.
 */
export async function getSharedAnalysis(id: string): Promise<AnalysisResultPayload> {
    try {
        const response = await fetch(`${API_BASE_URL}/analysis/${id}`);
        return handleApiResponse(response, 'getSharedAnalysis');
    } catch (error) {
        console.error(`Error in getSharedAnalysis:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to retrieve shared analysis: ${error.message}`);
        }
        throw new Error(`An unknown error occurred while retrieving shared analysis.`);
    }
}


/**
 * Sends user feedback to the backend.
 * @param type The type of feedback (e.g., 'Bug', 'Suggestion').
 * @param message The user's message.
 * @param email The user's optional email.
 */
export async function sendFeedback(type: string, message: string, email?: string): Promise<{ success: boolean }> {
    try {
        const response = await fetch(`${API_BASE_URL}/feedback`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type, message, email }),
        });
        return handleApiResponse(response, 'sendFeedback');
    } catch (error) {
        console.error(`Error in sendFeedback:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to send feedback: ${error.message}`);
        }
        throw new Error(`An unknown error occurred while sending feedback.`);
    }
}

/**
 * Submits a cleared track to the catalog.
 * @param formData The form data containing track details and the audio file.
 * @returns A promise that resolves to the newly created catalog item.
 */
export async function submitToCatalog(formData: FormData): Promise<CatalogItem> {
     try {
        const response = await fetch(`${API_BASE_URL}/catalog/submit`, {
            method: 'POST',
            body: formData,
        });
        return handleApiResponse(response, 'submitToCatalog');
    } catch (error) {
        console.error(`Error in submitToCatalog:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to submit to catalog: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during catalog submission.`);
    }
}

/**
 * Fetches all entries from the Cleared Catalog.
 * @returns A promise that resolves to an array of catalog items.
 */
export async function getCatalogEntries(): Promise<CatalogItem[]> {
    try {
        const response = await fetch(`${API_BASE_URL}/catalog/entries`);
        return handleApiResponse(response, 'getCatalogEntries');
    } catch (error) {
        console.error(`Error in getCatalogEntries:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to get catalog entries: ${error.message}`);
        }
        throw new Error(`An unknown error occurred while fetching catalog entries.`);
    }
}
